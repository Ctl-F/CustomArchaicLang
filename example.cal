proc Foo(entry: "main") {
    link stdio;

    static .cstr message0 = "Hello World\n";
    static .cstr message1 = "Your number is: ";


    static .ptr_ptr strings = { 0, 0 };

    fn get_strings() .ptr {
        [strings] = @message0;
        [strings + $sizeof{.ptr}] = @message1;
        return strings;
    }

    glob fn main(.i32 argc, .ptr_ptr argv) .i32 {
        stack .i32 root = 5;
        stack .i32 root_squared;
        stack .i32 root_cubed;

        root_squared = square(root);
        root_cubed = cube(root);

        stdio.print_str(message0);
        
        stdio.print_str(message1);
        stdio.print_i32(root_squared);

        stdio.putch('\n');

        stdio.print_str(message1);
        stdio.print_i32(root_cubed);

        stdio.putch('\n');

        return 0;
    }

    fn square(.i32 value) .i32 {
        stack .i32 result;
        
        result = value * value;

        return result;
    }

    fn cube(.i32 value) .i32 {
        stack .i32 result;

        result = value * value * value;

        return result;
    }

    fn populate(.i32 value) .i32 {
        stack .dword_ptr array = { 0, 0 };

        [ array ] = value;
        [ array + 1 ] = value;

        return value;
    }
}


lib stdio {
    c_include "stdio.h";

    
    glob fn print_str(.cstr ptr) {
        stack .cstr fmt = "%s";
        $c{{ printf(fmt, ptr); }};
    }
    glob fn print_i32(.i32 val) {
        stack .cstr fmt = "%d";
        $c{{ printf(fmt, val); }};
    }
    glob fn print_f32(.f32 val){
        stack .cstr fmt = "%f";
        $c{{ printf(fmt, val); }};
    }
    glob fn putch(.i8 ch) {
        $c{{ putchar(ch); }};
    }
}



/*
struct point {
    x .i32,
    y .i32
}

fn example(){
    stack .(point) origin;
    stack .(point) position;
    stack .ptr cursor;

    cursor = @origin;

    [ (.dword_ptr) cursor + $struct{point, x}] = 0;
    [ (.dword_ptr) cursor + $struct{point, y}] = 0;

    cursor = @position;

    [ (.dword_ptr) cursor + $struct{point, x}] = 10; // *(int*)(cursor + offsetof(struct point, x))
    [ (.dword_ptr) cursor + $struct{point, y}] = 100;
}

fn set_point(.ptr target_point, .i32 x, .i32 y){
    [ (.dword_ptr) target_point + $struct{point, x}] = x;
    [ (.dword_ptr) target_point + $struct{point, y}] = y;
}

fn add_point(.ptr dest_point, .ptr additional_point){
    [ (.dword_ptr) dest_point + $struct{point, x}] += 
        [ (.dword_ptr) additional_point + $struct{point, x}];

    [ (.dword_ptr) dest_point + $struct{point, y}] += 
        [ (.dword_ptr) additional_point + $struct{point, y}];
}

*/
/*
proc Foo(entry: "main") {
    link stdlib;
    link stdio, stdmath;

    static .cstr message0 = "Hello World\n";
    static .cstr message1 = "Your number is: ";

    glob fn main() {
        stack .i32 root = 5;
        stack .i32 root_squared;


        root_squared = -square(++root * (root-- + 1));

        stdio.print_str(message0);
        stdio.print_str(message1);
        stdio.print_i32(root_squared);
        stdio.putch('\n');
    }

    fn square(.i32 value) .i32 {
        stack .i32 result;

        result = value * value;
    }
}
*/
/*
proc Example(entry: main){
    link stdio;

    static .cstr format = "Hello %s\nNum: %d\n";
    static .cstr world = "World";

    glob fn main() {
        stack .i32 value = 5;
    }

    fn square(.i32 a, .i32 b) .i32 {
        return a * b;
    }

    fn factorial(.i32 n) .i32 {
        stack .i32 value;

        if(n <= 1){
            return 1;
        }

        value = 1;

        while(n > 1){
            value *= n;
            n--;
        }

        return value;
    }

}

lib stdio {
    glob fn printf(.cstr fmt, $va_args{}){
        $ccall("printf", fmt, $va_expand{});
    }
}
*/